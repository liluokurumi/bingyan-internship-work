# bingyan-internship-work
'因为没接触过开发活动,所以这个开发日志可能会跟学长们想的不太一样,我会尽量把自己的想法,每次更新的改动之类的都写在这里.
贪吃蛇大作战 开发日志

十月一日

实现目标：
-基本点：
-1:可操控的玩家蛇，能通过冲刺攻击其他玩家：
-        要点：贪吃蛇的运动方向由其头部偏转方向决定，其身体形状实际上就是其运动轨迹的一部分，因此考虑贪吃蛇运动时只需考虑其头部运动方向即可，而头部运动方向跟随鼠标指针所在方向移动，即只需键盘检测鼠标位置，再确认蛇头部位置即可确定运动方向，由于蛇的运动是不会停止的，因此这里要用角度而不是坐标进行移动，此时要设定一个移动速度——— 注意：蛇的运动速度每处相等，因此斜向运动时需要分解速度。
-                   冲刺：按下鼠标左键实现，移动速度变快，（有特效显示），随时间损失长度（以分数表示）
-2:会生长的身体：
-       要点：1，身体：slither里的蛇的身体由一个个圆形套起而成，因此可以创建一个蛇基类（一个个圈），蛇身类（继承蛇基类），蛇头类（继承蛇基类），蛇类（继承蛇身类，蛇头类）（负责连接蛇身和蛇头），蛇基类中每个圆都有一个中心坐标点，该点顺着蛇头移动的轨迹移动。
-                  2，生长：注意，上面所说的每个圆的点之间应隔一段相等的曲线距离（不知能否实现），能实现的话，生长就是扩大每段距离的长度，当扩大到一定程度后，距离变回原值，并在尾端再生成一个圆，另外圆的大小应该与每段距离长度乘点的个数的大小有关。
-3:随机生成的食物：
-      简单处理，在地图范围内指定随机个点（即食物），当需要再次刷新食物时，进行全场点数量的判定（点进入贪吃蛇范围内时，则应被删除）
-4:还原大逃杀的游戏机制：
-      地图为一个圆，随时间推移半径逐渐减小，蛇出地图则视为死亡。
-5:死亡机制：
-       首先要设定每条蛇的判定范围，初步想法是以每个蛇基类圆的范围为判定范围，当一条蛇的蛇头类碰撞到另一条蛇的蛇身类时，即判定前一条蛇死亡，但如何判定两个圆接触，也是个难题。
-6:本地AI控制的敌对蛇：可继承之前的蛇类
-    初步想法（脱离编程的想法）：首先，每个敌对AI的终极目标只有一个：努力让自己的长度（分数）更长，为实现这个目标，敌对AI有两个途径：寻找食物和杀死其他蛇。
-           1:寻找食物：（先不考虑其他蛇的影响）以敌对蛇的蛇头类的中心点为中心设定一个矩形范围，遍历该范围中所有的点，计算出每个点与蛇头类中心点的距离，并进行比较，并向距离最近的那个点  移动（这里可以用蛇类的移动方法），当那个点被删除后，再重新进行上述行为。
-            2:杀死其他蛇：这里需要以蛇头类为中心，建立一个索敌范围，范围内无其他蛇时，按上面那个行为逻辑行动，当有蛇时，则需要运用AI算法，（脱离编程），我的想法是设定两个范围：一个索敌范围，比较大，一个迎敌范围，比较小，当有蛇进入索敌范围时，先判断对面长度和自己的差距，自己弱则规避，自己强则迎击，进入迎敌范围时，再进行判定（此时要将敌对蛇蛇身和蛇头的点都纳入考虑），先计算出每个敌对蛇的点与自己蛇头点的距离，然后进行比较，取平均值，并算出每个点与点之间距离与平均值的差值，再表示出角度进行角度的加权计算，算出最佳角度，（蛇头）并向那个角度移动（无论有多少条蛇都同理）（注意：以上那段构想为规避），当距离实在太近时，使用加速。
